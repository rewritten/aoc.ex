# Day 11: Monkey in the Middle

```elixir
text = File.read!("Code/aoc.ex/input/2022/11.txt")
```

## AoC

<https://adventofcode.com/2022/day/11>

## Parser

```elixir
defmodule Parser do
  defmacro __using__(opts) do
    source = opts[:input] |> Code.eval_quoted() |> elem(0)

    decisions =
      for par <- String.split(source, "\n\n", trim: true) do
        String.split(par, "\n", trim: true)
      end

    starts =
      for {[_, start, _, _, _, _], i} <- Enum.with_index(decisions),
          [n] <- Regex.scan(~r|\d+|, start),
          do: {i, String.to_integer(n), 0}

    lcm =
      for [_, _, _, test, _, _] <- decisions, reduce: 1 do
        acc -> acc * (test |> String.split(" by ") |> List.last() |> String.to_integer())
      end

    [
      Code.string_to_quoted!("def start, do: #{inspect(starts)}"),
      for {[_, _, op, _, _, _], i} <- Enum.with_index(decisions) do
        op = String.replace_prefix(op, "  Operation: new = ", "")

        [
          Code.string_to_quoted!(
            "def insp({#{i}, old, i}, :relaxed), do: {#{i}, div(#{op}, 3), i}"
          ),
          Code.string_to_quoted!(
            "def insp({#{i}, old, i}, :nervous), do: {#{i}, rem(#{op}, #{lcm}), i}"
          )
        ]
      end,
      for {[_, _, _, test, ift, iff], i} <- Enum.with_index(decisions) do
        ift = ift |> String.split(" monkey ") |> List.last() |> String.to_integer()
        iff = iff |> String.split(" monkey ") |> List.last() |> String.to_integer()
        test = String.replace_prefix(test, "  Test: divisible by ", "")

        [
          Code.string_to_quoted!(
            "def toss({#{i}, n, i}) when rem(n, #{test}) == 0, do: {#{ift}, n, i#{if ift < i, do: " + 1"}}"
          ),
          Code.string_to_quoted!(
            "def toss({#{i}, n, i}), do: {#{iff}, n, i#{if iff < i, do: " + 1"}}"
          )
        ]
      end,
      quote do
        def run!(rounds, mode) do
          for item <- start() do
            item
            |> Stream.iterate(&(&1 |> insp(mode) |> toss()))
            |> Enum.take_while(fn {_, _, r} -> r < rounds end)
            |> Enum.map(&elem(&1, 0))
          end
          |> List.flatten()
          |> Enum.frequencies()
          |> Map.values()
          |> Enum.sort(:desc)
          |> Enum.take(2)
          |> Enum.reduce(&(&1 * &2))
        end
      end
    ]
  end
end
```

```elixir
defmodule DecisionExample do
  use Parser,
    input: """
    Monkey 0:
      Starting items: 79, 98
      Operation: new = old * 19
      Test: divisible by 23
        If true: throw to monkey 2
        If false: throw to monkey 3

    Monkey 1:
      Starting items: 54, 65, 75, 74
      Operation: new = old + 6
      Test: divisible by 19
        If true: throw to monkey 2
        If false: throw to monkey 0

    Monkey 2:
      Starting items: 79, 60, 97
      Operation: new = old * old
      Test: divisible by 13
        If true: throw to monkey 1
        If false: throw to monkey 3

    Monkey 3:
      Starting items: 74
      Operation: new = old + 3
      Test: divisible by 17
        If true: throw to monkey 0
        If false: throw to monkey 1
    """
end
```

```elixir
defmodule Decision do
  use Parser, input: File.read!("Code/aoc.ex/input/2022/11.txt")
end
```

## Part One

```elixir
Decision.run!(20, :relaxed)
```

## Part Two

```elixir
Decision.run!(10_000, :nervous)
```
